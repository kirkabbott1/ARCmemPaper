	Swift uses a system of memory management called Automatic Reference Counting (ARC). It keeps track of how many references there are to an object in your code. When a new reference is created, the reference count for that object increases. When a reference to an object goes out of scope and is no longer being used, the reference count for it decreases. When the reference count for something reaches zero, the memory assigned to that something gets released. ARC does this automatically.

	A retain cycle is when ARC fails where memory leaks can occur. This happens when two objects have strong references to each other that prevent them from being released. A way to avoid this is by distinguishing between strong and weak references in code. References are created as strong references by default. Strong refs increases the reference count for an object and prevents the object from being deallocated.

	Marking a reference as weak doesn't increase the reference count for the object. Declaring a reference as weak means the object that is referred is subject to disappearing which also means weak references must always be declared as optionals. If a weak reference points to something that disappears, the weak ref will be nil. If you don't want it to be nil, you can use "unowned" instead of "weak". 

	A conflicting access to memory can occur when different parts of your code are trying to access the same location in memory at the same time. Multiple accesses to a location in memory at the same time can produce unpredictable behavior. A conflict occurs if you have two accesses where one is a write access or a nonatomic access, they access the same location in memory, and their durations overlap. Swift usually takes care of this with automatic checks, but this can be avoided in code by doing things such as making explicit copies of variables.

